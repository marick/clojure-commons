<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>commons.clojure.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Clojure-commons 1.1.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>commons</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clojure</span></div></div></li><li class="depth-3 current"><a href="commons.clojure.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="commons.doc.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>doc</span></div></a></li><li class="depth-2"><a href="commons.ns.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ns</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="commons.clojure.core.html#var-.2Bfind-var"><div class="inner"><span>+find-var</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-.2Binto"><div class="inner"><span>+into</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-.2Bsymbol"><div class="inner"><span>+symbol</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var--.21.3E"><div class="inner"><span>-!&gt;</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var--.21.3E.3E"><div class="inner"><span>-!&gt;&gt;</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var--.3C.3E"><div class="inner"><span>-&lt;&gt;</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var--.3C.3E.3E"><div class="inner"><span>-&lt;&gt;&gt;</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-any.3F"><div class="inner"><span>any?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-bifurcate"><div class="inner"><span>bifurcate</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-big-decimal.3F"><div class="inner"><span>big-decimal?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-boom.21"><div class="inner"><span>boom!</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-branch-on"><div class="inner"><span>branch-on</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-cl-format"><div class="inner"><span>cl-format</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-classic-map.3F"><div class="inner"><span>classic-map?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-difference"><div class="inner"><span>difference</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-env"><div class="inner"><span>env</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-env-nil-ok"><div class="inner"><span>env-nil-ok</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-extended-fn.3F"><div class="inner"><span>extended-fn?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-find-first"><div class="inner"><span>find-first</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-form-hash"><div class="inner"><span>form-hash</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-fourth"><div class="inner"><span>fourth</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-guid"><div class="inner"><span>guid</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-has-root-value.3F"><div class="inner"><span>has-root-value?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-intersection"><div class="inner"><span>intersection</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-linear-access.3F"><div class="inner"><span>linear-access?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-multi.3F"><div class="inner"><span>multi?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-named.3F"><div class="inner"><span>named?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-namespace.3F"><div class="inner"><span>namespace?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-not-empty.3F"><div class="inner"><span>not-empty?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-only"><div class="inner"><span>only</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-pprint"><div class="inner"><span>pprint</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-prog1"><div class="inner"><span>prog1</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-regex.3F"><div class="inner"><span>regex?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-rename-keys"><div class="inner"><span>rename-keys</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-root-value"><div class="inner"><span>root-value</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-some-.3C.3E"><div class="inner"><span>some-&lt;&gt;</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-some-.3C.3E.3E"><div class="inner"><span>some-&lt;&gt;&gt;</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-str-blank.3F"><div class="inner"><span>str-blank?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-str-capitalize"><div class="inner"><span>str-capitalize</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-str-escape"><div class="inner"><span>str-escape</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-str-join"><div class="inner"><span>str-join</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-str-lower-case"><div class="inner"><span>str-lower-case</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-str-re-quote-replacement"><div class="inner"><span>str-re-quote-replacement</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-str-replace"><div class="inner"><span>str-replace</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-str-replace-first"><div class="inner"><span>str-replace-first</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-str-reverse"><div class="inner"><span>str-reverse</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-str-split"><div class="inner"><span>str-split</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-str-split-lines"><div class="inner"><span>str-split-lines</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-str-trim"><div class="inner"><span>str-trim</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-str-trim-newline"><div class="inner"><span>str-trim-newline</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-str-triml"><div class="inner"><span>str-triml</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-str-trimr"><div class="inner"><span>str-trimr</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-str-upper-case"><div class="inner"><span>str-upper-case</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-stringlike.3F"><div class="inner"><span>stringlike?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-subset.3F"><div class="inner"><span>subset?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-third"><div class="inner"><span>third</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-throw.2B"><div class="inner"><span>throw+</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-try.2B"><div class="inner"><span>try+</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-union"><div class="inner"><span>union</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-uuid"><div class="inner"><span>uuid</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-without-nils"><div class="inner"><span>without-nils</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">commons.clojure.core</h2><div class="doc"><div class="markdown"><p>Functions I wouldn&rsquo;t mind seeing in clojure.core</p></div></div><div class="public anchor" id="var-.2Bfind-var"><h3>+find-var</h3><div class="usage"><code>(+find-var name)</code><code>(+find-var ns name)</code></div><div class="doc"><div class="markdown"><p>Return a variable identified by the arguments, or <code>nil</code>. A version of the built-in function, but with a wider domain.</p><p><em>Case 1</em>: If the single argument is a namespace-qualified symbol, the behavior is the same as <code>clojure.core/find-var</code>: the variable of that name in that namespace is returned:</p>
<pre><code>(+find-var &#39;clojure.core/even?) =&gt; #&#39;clojure.core/even?
</code></pre><p>Note that the namespace <em>must</em> exist or an exception is thrown. </p><p>Strings with a single slash are treated as symbols:</p>
<pre><code>(+find-var &quot;clojure.core/even?&quot;) =&gt; #&#39;clojure.core/even?
</code></pre><p>Namespace-qualified keywords can also be used.</p><p><em>Case 2</em>: If the single argument is not namespace-qualified, it is treated as if it were qualified with <code>*ns*</code>:</p>
<pre><code>(+find-var &#39;find-var) =&gt; #&#39;this.namespace/find-var
(+find-var &quot;symbol&quot;) =&gt; #&#39;this.namespace/symbol
</code></pre><p><em>Case 3</em>: If the single argument is a var, it is returned.</p><p><em>Case 4</em>: In the two-argument case, the <code>ns</code> argument supplies the namespace and the <code>name</code> argument the var&rsquo;s name. <code>ns</code> may be a namespace, symbol, keyword, or string (<a href="null">as-ns-symbol</a>). <code>name</code> may be a string, symbol, keyword, or var. In the first three cases, the namespace part of <code>name</code> (if any) is ignored:</p>
<pre><code>(+find-var &#39;such.wide-domains &#39;clojure.core/find-var) =&gt; #&#39;such.wide-domains/find-var
(+find-var *ns* :find-var) =&gt; #&#39;this.namespace/find-var
</code></pre><p>If the <code>name</code> argument is a var, <code>find-var</code> looks for a var with the same name in <code>ns</code>:</p>
<pre><code>(+find-var &#39;such.wide-domains #&#39;clojure.core/find-var) =&gt; #&#39;such.wide-domains/find-var
</code></pre></div></div></div><div class="public anchor" id="var-.2Binto"><h3>+into</h3><div class="usage"><code>(+into coll &amp; colls)</code></div><div class="doc"><div class="markdown"><p>The result collection is formed by <code>conj</code>ing all elements of the other <code>colls</code> onto <code>coll</code> (in order). </p>
<pre><code>  (+into [] (map inc [1 2]) (map dec [-1 -2]))  =&gt; [2 3 -2 -3]
</code></pre><p><code>+into</code> is a convenient way to coerce a number of collections into a vector or other collection of your choice.</p><p>Note: the Clojure 1.7 version of <code>into</code> has a three argument version that takes a transducer as its second argument. Unlike in 1.6 and earlier, <code>+into</code> is not a compatible replacement for 1.7&rsquo;s <code>into</code>.</p></div></div></div><div class="public anchor" id="var-.2Bsymbol"><h3>+symbol</h3><div class="usage"><code>(+symbol name)</code><code>(+symbol ns name)</code></div><div class="doc"><div class="markdown"><p>Creates a symbol. A variant of the <code>clojure.core</code> version with a wider domain.<br/>The <code>ns</code> argument may be a namespace, symbol, keyword, or string (<a href="null">as-ns-string</a>).<br/>The <code>name</code> argument may be a symbol, string, keyword, or var (<a href="null">as-string-without-namespace</a>).</p><p>In the one-argument version, the resulting symbol has a <code>nil</code> namespace. In the two-argument version, it has the symbol version of <code>ns</code> as the namespace. Note that <code>ns</code> need not refer to an existing namespace.</p>
<pre><code>(+symbol &quot;th&quot;) =&gt; &#39;th
(+symbol &#39;clojure.core &quot;th&quot;) =&gt; &#39;clojure.core/th

(+symbol *ns* &#39;th) =&gt; &#39;this.namespace/th ; &quot;add&quot; a namespace
(+symbol *ns* &#39;clojure.core/even?) =&gt; &#39;this.namespace/even? ; &quot;localize&quot; a symbol.
</code></pre></div></div></div><div class="public anchor" id="var--.21.3E"><h3>-!&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(-!&gt; form &amp; forms)</code></div><div class="doc"><div class="markdown"><p>non-updating -&gt; for unobtrusive side-effects</p></div></div></div><div class="public anchor" id="var--.21.3E.3E"><h3>-!&gt;&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(-!&gt;&gt; form &amp; forms)</code></div><div class="doc"><div class="markdown"><p>non-updating -&gt;&gt; for unobtrusive side-effects</p></div></div></div><div class="public anchor" id="var--.3C.3E"><h3>-&lt;&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(-&lt;&gt; x)</code><code>(-&lt;&gt; x form)</code><code>(-&lt;&gt; x form &amp; forms)</code></div><div class="doc"><div class="markdown"><p>the &lsquo;diamond wand&rsquo;: top-level insertion of x in place of single positional &lsquo;&lt;&gt;&rsquo; symbol within the threaded form if present, otherwise mostly behave as the thread-first macro. Also works with hash literals and vectors.</p></div></div></div><div class="public anchor" id="var--.3C.3E.3E"><h3>-&lt;&gt;&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(-&lt;&gt;&gt; x)</code><code>(-&lt;&gt;&gt; x form)</code><code>(-&lt;&gt;&gt; x form &amp; forms)</code></div><div class="doc"><div class="markdown"><p>the &lsquo;diamond spear&rsquo;: top-level insertion of x in place of single positional &lsquo;&lt;&gt;&rsquo; symbol within the threaded form if present, otherwise mostly behave as the thread-last macro. Also works with hash literals and vectors.</p></div></div></div><div class="public anchor" id="var-any.3F"><h3>any?</h3><div class="usage"><code>(any? predlike coll)</code></div><div class="doc"><div class="markdown"><p><code>any?</code> provides shorthand for &ldquo;containment&rdquo; queries that otherwise require different functions. Behavior depends on the type of <code>predlike</code>.</p>
<ul>
  <li><p>A function: <code>true</code> iff <code>predlike</code> returns a <em>truthy</em> value for any value in <code>coll</code>.</p>
  <pre><code> (any? even? [1 2 3]) =&gt; true           ; works best with boolean-valued functions
 (any? inc [1 2 3]) =&gt; true             ; a silly example to demo truthiness.
 (any? identity [nil false]) =&gt; false   ; also silly
</code></pre></li>
  <li><p>A collection: <code>true</code> iff <code>predlike</code> contains any element of <code>coll</code>.</p>
  <pre><code> (any? #{1 3} [5 4 1]) =&gt; true
 (any? [1 3] [5 4 1]) =&gt; true
</code></pre><p>When <code>predlike</code> is a map, it checks key/value pairs:</p>
  <pre><code> (any? {:a 1} {:a 1}) =&gt; true
 (any? {:a 1} {:a 2}) =&gt; false
 (any? {:a 2, :b 1} {:b 1, :c 3}) =&gt; true
</code></pre></li>
  <li><p>A keyword: <code>true</code> iff <code>predlike</code> is a key in <code>coll</code>, which <em>must</em> be a map.</p>
  <pre><code> (any? :a {:a 1, :b 2}) =&gt; true         ; equivalent to:
 (contains? {:a 1, :b 2} :a) =&gt; true
</code></pre></li>
</ul></div></div></div><div class="public anchor" id="var-bifurcate"><h3>bifurcate</h3><div class="usage"><code>(bifurcate pred coll)</code></div><div class="doc"><div class="markdown"><p>Apply <code>pred</code> to all elements of <code>coll</code> and return two sequences. Those elements for which <code>pred</code> returns a truthy value go in the first sequence. <code>pred</code> is only evaluated once per element. Sequences are created lazily.</p>
<pre><code> (bifurcate even? [1 2 3 4]) =&gt; [ [2 4] [1 3] ]
 (take 5 (first (bifurcate even? (range)))) =&gt; [0 2 4 6 8]
</code></pre></div></div></div><div class="public anchor" id="var-big-decimal.3F"><h3>big-decimal?</h3><div class="usage"><code>(big-decimal? x)</code></div><div class="doc"><div class="markdown"><p>Is x a Java BigDecimal?</p></div></div></div><div class="public anchor" id="var-boom.21"><h3>boom!</h3><div class="usage"><code>(boom! fmt &amp; args)</code><code>(boom! exception-class fmt &amp; args)</code></div><div class="doc"><div class="markdown"><p>In the first case, throw a java.lang.Exception whose message was constructed by applying <code>format</code> to <code>fmt</code> and the <code>args</code>. In the second case, the exception thrown is given by <code>exception-class</code>.</p>
<pre><code>(boom! &quot;wow&quot;)
(boom! &quot;wow: %s&quot; (cons 1 (cons 2 nil)))
(boom! NumberFormatException &quot;wow: %s&quot; input)
</code></pre></div></div></div><div class="public anchor" id="var-branch-on"><h3>branch-on</h3><h4 class="type">macro</h4><div class="usage"><code>(branch-on value-form &amp; body)</code></div><div class="doc"><div class="markdown"><pre><code>(branch-on (str &quot;one&quot; &quot;two&quot;)
   vector?   :vector
   string?   :string
   :else     :unknown)
</code></pre><p>Evaluates the <code>value-form</code> once, then checks that value against each predicate in the cond-like body. The value after the first matching predicate is returned. If there is no match and an <code>:else</code> clause is present, its value is returned, otherwise <code>nil</code>.</p></div></div></div><div class="public anchor" id="var-cl-format"><h3>cl-format</h3><h4 class="added">added in 1.2</h4><div class="usage"><code>(cl-format writer format-in &amp; args)</code></div><div class="doc"><div class="markdown"><p>An implementation of a Common Lisp compatible format function. cl-format formats its arguments to an output stream or string based on the format control string given. It supports sophisticated formatting of structured data.</p><p>Writer is an instance of java.io.Writer, true to output to <em>out</em> or nil to output to a string, format-in is the format control string and the remaining arguments are the data to be formatted.</p><p>The format control string is a string to be output with embedded &lsquo;format directives&rsquo; describing how to format the various arguments passed in.</p><p>If writer is nil, cl-format returns the formatted result string. Otherwise, cl-format returns nil.</p><p>For example:  (let [results [46 38 22]]  (cl-format true &ldquo;There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%&rdquo;  (count results) results))</p><p>Prints to <em>out</em>:  There are 3 results: 46, 38, 22</p><p>Detailed documentation on format control strings is available in the &ldquo;Common Lisp the Language, 2nd edition&rdquo;, Chapter 22 (available online at: <a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000">http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000</a>) and in the Common Lisp HyperSpec at <a href="http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm">http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm</a></p></div></div></div><div class="public anchor" id="var-classic-map.3F"><h3>classic-map?</h3><div class="usage"><code>(classic-map? x)</code></div><div class="doc"><div class="markdown"><p><code>map?</code> will return true for Records. This returns true only for hashmaps and sorted maps.</p></div></div></div><div class="public anchor" id="var-difference"><h3>difference</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(difference s1)</code><code>(difference s1 s2)</code><code>(difference s1 s2 &amp; sets)</code></div><div class="doc"><div class="markdown"><p>Return a set that is the first set without elements of the remaining sets</p></div></div></div><div class="public anchor" id="var-env"><h3>env</h3><div class="usage"><code>(env key)</code></div><div class="doc"><div class="markdown"><p>Select a keyword <code>key</code> from the environment. The result is a string. Throws an error if the environment lookup returns <code>nil</code>. See <a href="commons.clojure.core.html#var-env-nil-ok">env-nil-ok</a>.</p><p>Environment variables are handled as described in <a href="https://github.com/weavejester/environ">weavejester/environ</a>:</p>
<pre><code> (env :home)          ; lowercased
 (env :database-url)  ; would match `DATABASE_URL`
</code></pre><p>Also see that documentation for where environment variables can be set.</p></div></div></div><div class="public anchor" id="var-env-nil-ok"><h3>env-nil-ok</h3><div class="usage"><code>(env-nil-ok key)</code></div><div class="doc"><div class="markdown"><p>Select a keyword <code>key</code> from the environment, returning a string. The result may be <code>nil</code>.</p></div></div></div><div class="public anchor" id="var-extended-fn.3F"><h3>extended-fn?</h3><div class="usage"><code>(extended-fn? x)</code></div><div class="doc"><div class="markdown"><p><code>fn?</code> does not consider multimethods to be functions. This does.</p></div></div></div><div class="public anchor" id="var-find-first"><h3>find-first</h3><div class="usage"><code>(find-first pred coll)</code></div><div class="doc"><div class="markdown"><p>Returns the first item of <code>coll</code> where <code>(pred item)</code> returns a truthy value, <code>nil</code> otherwise. <code>coll</code> is evaluated lazily.</p>
<pre><code> (find-first even? [1 2 3]) =&gt; 2
</code></pre><p>You can apply <code>find-first</code> to a map, even though which element matches &ldquo;first&rdquo; is undefined. Note that the item passed to <code>pred</code> will be a key-value pair:</p>
<pre><code> (find-first #(even? (second %)) {:a 2, :b 22, :c 222}) =&gt; [:c 222]
</code></pre></div></div></div><div class="public anchor" id="var-form-hash"><h3>form-hash</h3><div class="usage"><code>(form-hash form)</code></div><div class="doc"><div class="markdown"><p>Returns a SHA-1 hash (encoded as a hex string) from the <code>prn</code> representation of the input. Use for collision avoidance when the highest security is not needed.</p></div></div></div><div class="public anchor" id="var-fourth"><h3>fourth</h3><div class="usage"><code>(fourth coll)</code></div><div class="doc"><div class="markdown"><p>Returns the fourth element of <code>coll</code>. Returns <code>nil</code> if there are fewer than four elements.</p></div></div></div><div class="public anchor" id="var-guid"><h3>guid</h3><div class="usage"><code>(guid)</code></div><div class="doc"><div class="markdown"><p>A random almost-certainly-unique identifier</p></div></div></div><div class="public anchor" id="var-has-root-value.3F"><h3>has-root-value?</h3><div class="usage"><code>(has-root-value? this)</code></div><div class="doc"><div class="markdown"><p>Does this var have a root value?</p></div></div><div class="src-link"><a href="https://github.com/marick/clojure-commons/blob/master/src/commons/clojure/core.clj#L22">view source</a></div></div><div class="public anchor" id="var-intersection"><h3>intersection</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(intersection s1)</code><code>(intersection s1 s2)</code><code>(intersection s1 s2 &amp; sets)</code></div><div class="doc"><div class="markdown"><p>Return a set that is the intersection of the input sets</p></div></div></div><div class="public anchor" id="var-linear-access.3F"><h3>linear-access?</h3><div class="usage"><code>(linear-access? x)</code></div><div class="doc"><div class="markdown"><p>Is the collection one where you can&rsquo;t do better than linear access?</p></div></div></div><div class="public anchor" id="var-multi.3F"><h3>multi?</h3><div class="usage"><code>(multi? x)</code></div><div class="doc"><div class="markdown"><p>Was <code>x</code> created with <code>defmulti</code>?</p></div></div></div><div class="public anchor" id="var-named.3F"><h3>named?</h3><div class="usage"><code>(named? x)</code></div><div class="doc"><div class="markdown"><p>Will <code>name</code> work on x? Two cases: It implements the Named protocol OR it&rsquo;s a string.</p></div></div></div><div class="public anchor" id="var-namespace.3F"><h3>namespace?</h3><div class="usage"><code>(namespace? x)</code></div><div class="doc"><div class="markdown"><p>Is x a namespace?</p></div></div></div><div class="public anchor" id="var-not-empty.3F"><h3>not-empty?</h3><div class="usage"><code>(not-empty? value)</code></div><div class="doc"><div class="markdown"><p>Returns <code>true</code> if <code>value</code> has any values, <code>false</code> otherwise. <code>value</code> <em>must</em> be a collection, a String, a native Java array, or something that implements the <code>Iterable</code> interface.</p></div></div></div><div class="public anchor" id="var-only"><h3>only</h3><div class="usage"><code>(only coll)</code></div><div class="doc"><div class="markdown"><p>Gives the first element of a sequence. Throws an exception if there is not exactly one element.</p></div></div></div><div class="public anchor" id="var-pprint"><h3>pprint</h3><h4 class="added">added in 1.2</h4><div class="usage"><code>(pprint object)</code><code>(pprint object writer)</code></div><div class="doc"><div class="markdown"><p>Pretty print object to the optional output writer. If the writer is not provided, print the object to the currently bound value of <em>out</em>.</p></div></div></div><div class="public anchor" id="var-prog1"><h3>prog1</h3><h4 class="type">macro</h4><div class="usage"><code>(prog1 retform &amp; body)</code></div><div class="doc"><div class="markdown"><p>The <code>retform</code> is evaluated, followed by the <code>body</code>. The value of the form is returned, so the point of <code>body</code> should be to have side-effects.</p>
<pre><code>(defn pop! [k]
   (prog1 (top k)
     (alter! k clojure.core/pop)))
</code></pre><p>The name is a homage to older Lisps.</p></div></div></div><div class="public anchor" id="var-regex.3F"><h3>regex?</h3><div class="usage"><code>(regex? x)</code></div><div class="doc"><div class="markdown"><p>Is x a regular expression (a Java Pattern)?</p></div></div></div><div class="public anchor" id="var-rename-keys"><h3>rename-keys</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(rename-keys map kmap)</code></div><div class="doc"><div class="markdown"><p>Returns the map with the keys in kmap renamed to the vals in kmap</p></div></div></div><div class="public anchor" id="var-root-value"><h3>root-value</h3><div class="usage"><code>(root-value this)</code></div><div class="doc"><div class="markdown"><p>What is the value of the var, ignoring any bindings in effect?</p></div></div><div class="src-link"><a href="https://github.com/marick/clojure-commons/blob/master/src/commons/clojure/core.clj#L22">view source</a></div></div><div class="public anchor" id="var-some-.3C.3E"><h3>some-&lt;&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(some-&lt;&gt; x form)</code><code>(some-&lt;&gt; x form &amp; forms)</code></div><div class="doc"><div class="markdown"><p>the diamond wand version of some-&gt;</p></div></div></div><div class="public anchor" id="var-some-.3C.3E.3E"><h3>some-&lt;&gt;&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(some-&lt;&gt;&gt; x form)</code><code>(some-&lt;&gt;&gt; x form &amp; forms)</code></div><div class="doc"><div class="markdown"><p>the diamond wand version of some-&gt;&gt;</p></div></div></div><div class="public anchor" id="var-str-blank.3F"><h3>str-blank?</h3><h4 class="added">added in 1.2</h4><div class="usage"><code>(str-blank? s)</code></div><div class="doc"><div class="markdown"><p>True if s is nil, empty, or contains only whitespace.</p></div></div></div><div class="public anchor" id="var-str-capitalize"><h3>str-capitalize</h3><h4 class="added">added in 1.2</h4><div class="usage"><code>(str-capitalize s)</code></div><div class="doc"><div class="markdown"><p>Converts first character of the string to upper-case, all other characters to lower-case.</p></div></div></div><div class="public anchor" id="var-str-escape"><h3>str-escape</h3><h4 class="added">added in 1.2</h4><div class="usage"><code>(str-escape s cmap)</code></div><div class="doc"><div class="markdown"><p>Return a new string, using cmap to escape each character ch from s as follows:</p><p>If (cmap ch) is nil, append ch to the new string. If (cmap ch) is non-nil, append (str (cmap ch)) instead.</p></div></div></div><div class="public anchor" id="var-str-join"><h3>str-join</h3><h4 class="added">added in 1.2</h4><div class="usage"><code>(str-join coll)</code><code>(str-join separator coll)</code></div><div class="doc"><div class="markdown"><p>Returns a string of all elements in coll, as returned by (seq coll), separated by an optional separator.</p></div></div></div><div class="public anchor" id="var-str-lower-case"><h3>str-lower-case</h3><h4 class="added">added in 1.2</h4><div class="usage"><code>(str-lower-case s)</code></div><div class="doc"><div class="markdown"><p>Converts string to all lower-case.</p></div></div></div><div class="public anchor" id="var-str-re-quote-replacement"><h3>str-re-quote-replacement</h3><h4 class="added">added in 1.5</h4><div class="usage"><code>(str-re-quote-replacement replacement)</code></div><div class="doc"><div class="markdown"><p>Given a replacement string that you wish to be a literal replacement for a pattern match in replace or replace-first, do the necessary escaping of special characters in the replacement.</p></div></div></div><div class="public anchor" id="var-str-replace"><h3>str-replace</h3><h4 class="added">added in 1.2</h4><div class="usage"><code>(str-replace s match replacement)</code></div><div class="doc"><div class="markdown"><p>Replaces all instance of match with replacement in s.</p><p>match/replacement can be:</p><p>string / string char / char pattern / (string or function of match).</p><p>See also replace-first.</p><p>The replacement is literal (i.e. none of its characters are treated specially) for all cases above except pattern / string.</p><p>For pattern / string, $1, $2, etc. in the replacement string are substituted with the string that matched the corresponding parenthesized group in the pattern. If you wish your replacement string r to be used literally, use (re-quote-replacement r) as the replacement argument. See also documentation for java.util.regex.Matcher&rsquo;s appendReplacement method.</p><p>Example: (clojure.string/replace &ldquo;Almost Pig Latin&rdquo; #&ldquo;\b(\w)(\w+)\b&rdquo; &ldquo;$2$1ay&rdquo;) -&gt; &ldquo;lmostAay igPay atinLay&rdquo;</p></div></div></div><div class="public anchor" id="var-str-replace-first"><h3>str-replace-first</h3><h4 class="added">added in 1.2</h4><div class="usage"><code>(str-replace-first s match replacement)</code></div><div class="doc"><div class="markdown"><p>Replaces the first instance of match with replacement in s.</p><p>match/replacement can be:</p><p>char / char string / string pattern / (string or function of match).</p><p>See also replace.</p><p>The replacement is literal (i.e. none of its characters are treated specially) for all cases above except pattern / string.</p><p>For pattern / string, $1, $2, etc. in the replacement string are substituted with the string that matched the corresponding parenthesized group in the pattern. If you wish your replacement string r to be used literally, use (re-quote-replacement r) as the replacement argument. See also documentation for java.util.regex.Matcher&rsquo;s appendReplacement method.</p><p>Example: (clojure.string/replace-first &ldquo;swap first two words&rdquo;  #&ldquo;(\w+)(\s+)(\w+)&rdquo; &ldquo;$3$2$1&rdquo;) -&gt; &ldquo;first swap two words&rdquo;</p></div></div></div><div class="public anchor" id="var-str-reverse"><h3>str-reverse</h3><h4 class="added">added in 1.2</h4><div class="usage"><code>(str-reverse s)</code></div><div class="doc"><div class="markdown"><p>Returns s with its characters reversed.</p></div></div></div><div class="public anchor" id="var-str-split"><h3>str-split</h3><h4 class="added">added in 1.2</h4><div class="usage"><code>(str-split s re)</code><code>(str-split s re limit)</code></div><div class="doc"><div class="markdown"><p>Splits string on a regular expression. Optional argument limit is the maximum number of splits. Not lazy. Returns vector of the splits.</p></div></div></div><div class="public anchor" id="var-str-split-lines"><h3>str-split-lines</h3><h4 class="added">added in 1.2</h4><div class="usage"><code>(str-split-lines s)</code></div><div class="doc"><div class="markdown"><p>Splits s on \n or \r\n.</p></div></div></div><div class="public anchor" id="var-str-trim"><h3>str-trim</h3><h4 class="added">added in 1.2</h4><div class="usage"><code>(str-trim s)</code></div><div class="doc"><div class="markdown"><p>Removes whitespace from both ends of string.</p></div></div></div><div class="public anchor" id="var-str-trim-newline"><h3>str-trim-newline</h3><h4 class="added">added in 1.2</h4><div class="usage"><code>(str-trim-newline s)</code></div><div class="doc"><div class="markdown"><p>Removes all trailing newline \n or return \r characters from string. Similar to Perl&rsquo;s chomp.</p></div></div></div><div class="public anchor" id="var-str-triml"><h3>str-triml</h3><h4 class="added">added in 1.2</h4><div class="usage"><code>(str-triml s)</code></div><div class="doc"><div class="markdown"><p>Removes whitespace from the left side of string.</p></div></div></div><div class="public anchor" id="var-str-trimr"><h3>str-trimr</h3><h4 class="added">added in 1.2</h4><div class="usage"><code>(str-trimr s)</code></div><div class="doc"><div class="markdown"><p>Removes whitespace from the right side of string.</p></div></div></div><div class="public anchor" id="var-str-upper-case"><h3>str-upper-case</h3><h4 class="added">added in 1.2</h4><div class="usage"><code>(str-upper-case s)</code></div><div class="doc"><div class="markdown"><p>Converts string to all upper-case.</p></div></div></div><div class="public anchor" id="var-stringlike.3F"><h3>stringlike?</h3><div class="usage"><code>(stringlike? x)</code></div><div class="doc"><div class="markdown"><p>Is x a string or a regex?</p></div></div></div><div class="public anchor" id="var-subset.3F"><h3>subset?</h3><h4 class="added">added in 1.2</h4><div class="usage"><code>(subset? set1 set2)</code></div><div class="doc"><div class="markdown"><p>Is set1 a subset of set2?</p></div></div></div><div class="public anchor" id="var-third"><h3>third</h3><div class="usage"><code>(third coll)</code></div><div class="doc"><div class="markdown"><p>Returns the third element of <code>coll</code>. Returns <code>nil</code> if there are fewer than three elements.</p></div></div></div><div class="public anchor" id="var-throw.2B"><h3>throw+</h3><h4 class="type">macro</h4><div class="usage"><code>(throw+)</code><code>(throw+ object cause? message-or-fmt? &amp; fmt-args)</code></div><div class="doc"><div class="markdown"><p>Like the throw special form, but can throw any object by wrapping non-Throwable objects in a Throwable wrapper.</p><p>throw+ has the same syntax and behavior as throw for Throwable objects. The message, cause, and stack trace are those carried by the Throwable.</p><p>For non-Throwable objects, the message and cause have default values which can be overridden by optional arguments:</p><p>(throw+ object cause? message-or-fmt? &amp; fmt-args)</p>
<ul>
  <li><p>object: required, the object to throw</p></li>
  <li><p>cause: optional, a Throwable, the default is:</p>
  <ul>
    <li>within a try+ catch clause, the the outermost wrapper of  the caught object being processed,</li>
  </ul>
  <ul>
    <li>elsewhere, nil.</li>
  </ul></li>
  <li><p>message: optional, specified either as a string or a format string and args for clojure.core/format:</p>
  <ul>
    <li>% symbols anywhere within args name the thrown object</li>
  </ul>
  <ul>
    <li>the default is: &ldquo;throw+: %s&rdquo; (pr-str %)</li>
  </ul></li>
</ul><p>The stack trace is that of the current thread at the time of the throw+ call, starting at the function that encloses it;</p><p>Within a try+ catch clause, a throw+ call with no arguments rethrows the caught object within its original (possibly nested) wrappers.</p><p>See also try+, get-throw-context</p></div></div></div><div class="public anchor" id="var-try.2B"><h3>try+</h3><h4 class="type">macro</h4><div class="usage"><code>(try+ &amp; body)</code></div><div class="doc"><div class="markdown"><p>Like the try special form, but with enhanced catch clauses and an optional else clause:</p>
<ul>
  <li><p>catch non-Throwable objects thrown by throw+ or data made throwable by ex-info as well as Throwable objects thrown by throw or throw+;</p></li>
  <li><p>specify objects to catch by class name, key-values, predicate, or arbitrary selector form;</p></li>
  <li><p>destructure the caught object;</p></li>
  <li><p>an optional else clause may appear after all catch clauses and before any finally clause. Its contents will be executed (for side effects) immediately after the code in the try+ body completes only if nothing was thrown.</p></li>
</ul><p>A selector form is a form containing one or more instances of % to be replaced by the thrown object. If it evaluates to truthy, the object is caught.</p><p>The class name, key-values, and predicate selectors are  shorthand for these selector forms:</p>
<pre><code>&lt;class name&gt;          =&gt; (instance? &lt;class name&gt; %)
[&lt;key&gt; &lt;val&gt; &amp; &lt;kvs&gt;] =&gt; (and (= (get % &lt;key&gt;) &lt;val&gt;) ...)
&lt;predicate&gt;           =&gt; (&lt;predicate&gt; %)
</code></pre><p>The binding form in a try+ catch clause is not required to be a simple symbol. It is subject to destructuring which allows easy access to the contents of a thrown collection.</p><p>The local &amp;throw-context is available within try+ catch clauses, bound to the throw context for the caught object.</p><p>See also: throw+, get-throw-context</p></div></div></div><div class="public anchor" id="var-union"><h3>union</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(union)</code><code>(union s1)</code><code>(union s1 s2)</code><code>(union s1 s2 &amp; sets)</code></div><div class="doc"><div class="markdown"><p>Return a set that is the union of the input sets</p></div></div></div><div class="public anchor" id="var-uuid"><h3>uuid</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Synonym for <code>guid</code></p></div></div></div><div class="public anchor" id="var-without-nils"><h3>without-nils</h3><div class="usage"><code>(without-nils coll)</code></div><div class="doc"><div class="markdown"><p>A lazy sequence of non-nil values of <code>coll</code>.</p></div></div></div></div></body></html>